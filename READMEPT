
Boas Práticas em iOS 
==================

_Assim como o software, este documento vai ficar ultrapassado se não tomarmos cuidado. Nos estimulamos que todos nos ajude com isso – Basta apenas abrir uma questão ou enviar um pull request!_

Interessado em outras plataformas mobile? Nossas [Melhores praticas para desenvolvimento Android][android-best-practices] e [Melhores praticas para desenvolvimento de aplicativos Windows][windows-app-development-best-practices].

[android-best-practices]: https://github.com/futurice/android-best-practices
[windows-app-development-best-practices]: https://github.com/futurice/windows-app-development-best-practices

## Por quê?

Começar com iOS pode ser intimidador. Nem Swift, nem Objective-C são amplamente utilizados em outros lugares, a plataforma tem seus próprios nomes para quase tudo, e é uma estrada "esburacada" para seu próprio código, efetivamente para fazê-lo em um dispositivo físico. Este documento existente ira ajuda-lo, se você esta dando os primeiros passos dentro do Cocoaland ou esta curioso sobre como fazer as coisas da "maneira certa". Tudo abaixo são apenas sugestões, então se voce tiver alguma razão para fazer algo diferente por outros meios, vá em frente!

## Conteúdo

Se você está procurando algo específico, você pode ir ate as seções relevantes adiante.

1. [Getting Started](#getting-started)
1. [Common Libraries](#common-libraries)
1. [Architecture](#architecture)
1. [Networking](#networking)
1. [Assets](#assets)
1. [Coding Style](#coding-style)
1. [Diagnostics](#diagnostics)
1. [Analytics](#analytics)
1. [Building](#building)
1. [Deployment](#deployment)
1. [In-App Purchases (IAP)](#in-app-purchases-iap)
1. [License](#license)

## Começando

### Xcode

[Xcode][xcode] É uma IDE utilizada pelos desenvolvedores iOS, e é a unica oficialmente suportada pela Apple. Existe algumas alternativas, da qual [AppCode][appcode] é indiscutivelmente a mais famosa, mas ao menos que você seja uma pessoas experiente em iOS, use Xcode. apesar das suas deficiências, ele é realmente muito útil nos dias de hoje!

Para instalar, faça o download [Xcode no Mac App Store][xcode-app-store]. Ele vem com a mais nova SDK e simulador, e você pode instalar mais materiais em ->Preferences -> Downloads.

[xcode]: https://developer.apple.com/xcode/
[appcode]: https://www.jetbrains.com/objc/
[xcode-app-store]: https://itunes.apple.com/us/app/xcode/id497799835

### Setup do projeto

Uma questão comum quando começamos um projeto no iOS se é para escrever todos os códigos na View ou na Interface Builder com Storyboards ou XIB files. Ambos são conhecidos por ocasionalmente resultar no funcionamento do código. Contudo, há algumas considerações:

#### Por quê código?
* Storyboards são mais propensos a conflitos de versão devido a sua complexa estrutura XML. Isso torna o merging mais difícil com o código.
* Ele é mais fácil de estruturar e reusar os códigos na view, mantendo assim seu codebase [DRY][dry].
* Todas informações estão em um lugar. Na Interface Builder você tem que clicar através de todos os inspectors para encontrar o que você está procurando.

[dry]: http://en.wikipedia.org/wiki/Don%27t_repeat_yourself

#### Por quê Storyboards?
* Para os leigos tecnicos, Storyboard pode ser uma ótima maneira de contribuir diretamente para o projeto, e.g. para ajustes de cores ou restrições de layout. Entretanto, isso requer uma configuração do projeto de trabalho e algum tempo para aprender o básico.
* Interação é muitas vezes mais rápido, pois você pode visualizar certas mudanças sem a construção do projeto.
* No Xcode 6, fontes personalizadas e elementos UI são finalmente representadas visualmente no Storyboards, dando à você uma ideia melhor da aparência final enquanto desenha.
* Começando com iOS 8, [Classes de tamanho][size-classes] permite você desenhar para diferentes tipos de dispositivos e telas sem duplicação.

[size-classes]: http://blog.futurice.com/adaptive-view-ios8

### Ignores

Um bom primeiro passo ao colocar um projeto sob controle de versão é ter um decente arquivo ".gitignore". Dessa maneira, arquivos indesejáveis (definições de usuários, arquivos temporários, etc.) nunca farão parte do seu repositório. Felizmente, GitHub cobriu [Objective-C][objc-gitignore] e [Swift][swift-gitignore].

[objc-gitignore]: https://github.com/github/gitignore/blob/master/Objective-C.gitignore
[swift-gitignore]: https://github.com/github/gitignore/blob/master/Swift.gitignore

### CocoaPods

Se você está planejando incluir dependências externas (e.g. third-party libraries) em seu projeto, [CocoaPods][cocoapods] oferece uma rápida e fácil integração. Instale no terminal:

    sudo gem install cocoapods

Para começar, mova dentro da sua pasta de projeto de iOS e rode.

    pod init

Isso cria um Podfile, que vai realizar todas as suas dependências em um só lugar. Depois de adicionar suas dependências no Podfile, você roda

    pod install

Para instalar as libraries e inclui-las como parte do seu workspace que também detem do seu próprio projeto. Ele é geralmente [recomendado para comitar a instalação da dependência do seu próprio repositório][committing-pods], em vez de confiar e ter cada desenvolvedor rodando "pod install" depois de um novo check-out.

Note que apartir de agora, você vai precisar abrir o ".xcworkspace" em vez de ".xcproject", ou seu código não será compilado. O comando

    pod update

Aualizará todos os pods para as versões mais recentes permitidas pelo Podfile . Você pode usar uma grande variadades [Operadores][cocoapods-pod-syntax] para especificar seu requerimento de versão.

[cocoapods]: http://www.cocoapods.org
[cocoapods-pod-syntax]: http://guides.cocoapods.org/syntax/podfile.html#pod
[committing-pods]: https://www.dzombak.com/blog/2014/03/including-pods-in-source-control.html

### Estrutura de projeto

Para manter todas aquelas centenas de arquivos de origem terminando no mesmo diretório, É uma boa ideia para configurar algumas estruturas de pastas que depende da sua arquitetura. Por exemplo, você pode usar a seguir:

    ├─ Models
    ├─ Views
    ├─ Controllers
    ├─ Stores
    ├─ Helpers

Primeiro, cria-los como grupos (amarelo claro "folders") dentro do grupo com o nome do seu projeto no Project Navigator do Xcode. Então , para cada um dos grupos, liga-lo a um diretório atual no caminho do seu projeto barindo o File Inspector a direita, clicando no icone da pasta em cinza claro, e criando um novo subfolder com o nome do grupo em seu diretório do projeto.

#### Localização

Mantenha todas as strings dos usuários em arquivos de localização desde o início. Isso é bom não só para traduções, mas também para descobrir textos rapidamente voltados para usuário. Você pode adicionar um argumento de inicio para o seu esquema de compilação para iniciar o aplicativo em uma determinada línguagem ,e.g.

    -Linguagens da Apple (Finnish)

Para traduções mais complexas, tais como formas plurais que , dependendo do número de itens(e.g. "1 pessoa" vs. "3 pessoas"), você deve usar o [".stringsdict" format][stringsdict-format] em vez de um arquivo regular "localizable.strings". Assim que você tem em volta da sua head uma syntax louca, você tem um acessório poderoso que sabe como fazer plurais para "uns", "umas", "poucos" e "muitos" itens, como necessário [e.g. in Russian or Arabic][language-plural-rules].

Encontre mais informações sobre localização em [Estas representações de slides][l10n-slides] de fevereiro de 2012 HelsinkiOS meetup. A maior parte da conversa ainda é relevante em Outobro de 2014.

[stringsdict-format]: https://developer.apple.com/library/prerelease/ios/documentation/MacOSX/Conceptual/BPInternational/StringsdictFileFormat/StringsdictFileFormat.html
[language-plural-rules]: http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
[l10n-slides]: https://speakerdeck.com/hasseg/localization-practicum

#### Constants

Mantenha as constantes no app-wide "Constants.h" arquivo será  incluído no cabeçalho dos prefix.
.

Em vez de definições de macro pré-processados(via "#define"), use a actual constant:

    static CGFloat const XYZBrandingFontSizeSmall = 12.0f;
    static NSString * const XYZAwesomenessDeliveredNotificationName = @"foo";

Actual constants são de tipo seguro, tem um escopo mais explicito (they’re not available in all imported/included files until undefined), não pode ser redefinido ou indefinido em partes posteriores do código, e estão disponíveis no debugger.


### Modelo de Branching

Especialmente quando a distribuição de um aplicativo para público(e.g. through the App Store), é uma boa ideia para isolar o inicio da sua própria branch com marcas próprias.Também, a caracteristica do trabalho envolve uma serie de commits que fazem parte da sua própria branch . ["git-flow"][gitflow-github] é uma ferramenta para auxiliar você nestas convenções. Ele é uma simples vantagem ao redor da branching em comandos de marcação do Git, mas pode ajudar a manter uma branching própria e estruturada especialmente para equipes. Fazer todo o desenvolvimento em função das branches (ou em "develop" para um pequeno trabalho), para iniciar marcação com versões do app, e comitar para master é somente via

    git flow release finish <version>

[gitflow-github]: https://github.com/nvie/gitflow

## Common Libraries

Geralmente falando, faça disso uma decisão conciente para adicionar uma depenência externa para seu próprio projeto. Certamente, essa agradável library resolverá seus problemas por agora, mas talvez depois ficará preso na manutenção do limbo, com a próxima versão do OS . Outro cenário que é um recurso só alcançável com bibliotecas externas que de repente se tornam parte da API oficial. Em um codebase bem concebido,alternando a implementação é uma pequeno esforço que é rapidamente compensado. Sempre considere resolver o problema usando a extensão da Apple (e principalemente excelente) primeiro frameworks!

Portanto essa sessão foi deliberadamente mantida curta. As libraries caracterizadas tendem a reduzir um código clichê  (e.g. Auto Layout) ou resolver um problema complexo que requer testes extensivos, tal como calculo de datas. Para se tornar mais proeficiente com iOS, certifique-se em manter a fonte aqui e ali, e familiarizar-se com o básico do Framework da Apple. Você vai descobrir que esses sozinho podem fazer muito do trabalho pesado.

### AFNetworking

Uma porcentagem de 99.95% de desenvolvedores iOS usam essa library de network . Enquanto "NSURLSession" é surpreendentemente potente por si só, [AFNetworking][afnetworking-github] permanece imbativel quando se trata de uma ferramente de gerenciar fila de pedidos, que é praticamente uma exigência em qualquer app moderno.

[afnetworking-github]: https://github.com/AFNetworking/AFNetworking

### DateTools
Como uma regra geral, [Não escreva você mesmo sua calculação de data][timezones-youtube]. Felizmente, no [DateTools][datetools-github] você obtém uma licenciatura MIT, biblioteca exaustivamente testada que cobre praticamente todas as suas necessidades do calendary.

[timezones-youtube]: https://www.youtube.com/watch?v=-5wpm-gesOY
[datetools-github]: https://github.com/MatthewYork/DateTools

### Auto Layout Libraries
Se você prefere escrever suas views no código, provavelmente você já conheceu provavelmente, você já conheceu ou de sintaxes estranhas da Apple – o regular 'NSLayoutConstraint' fabric ou a layer [Visual Format Language][visual-format-language]. O primeiro é extremamente detalhado e este último baseado em strings, que efetivamente impede de compilar
-time checking.

[Masonry][masonry-github] Recurso para introdução da própria DSL para fazer, atualizar e repor restrições. Uma abordagem semelhante para o swift é tomado por [Cartography][cartography-github], O qual baseia-se em poderosos recursos de sobrecarga de um operador da linguagem. Para os mais conservadores, [FLKAutoLayout][flkautolayout-github] oferece um limpo, mas em vez de empacotador non-magic em volta das APIs nativas.

[visual-format-language]: https://developer.apple.com/library/ios/documentation/userexperience/conceptual/AutolayoutPG/VisualFormatLanguage/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH3-SW1
[masonry-github]: https://www.github.com/Masonry/Masonry
[cartography-github]: https://github.com/robb/Cartography
[flkautolayout-github]: https://github.com/floriankugler/FLKAutoLayout

## Architecture (Arquitetura)

* [Model-View-Controller-Store (MVCS)][mvcs]
    * Essa é uma arquitetura padrão da Apple (MVC), prorrogado por uma store layer e lida com o trabalho em rede, armazenamento em cache etc.
    * Cada Store expõe a uma view controller `RACSignal`s ou `void`- retornando metodos personalizados com realização de blocos.
* [Model-View-ViewModel (MVVM)][mvvm]
    * Motivado por "massive view controllers": MVVM considera `UIViewController` uma subclasse que parte da View que vem mantendo pequeno em todo o estado da View Model
    * Conceito muito novo para desenvolvedores Cocoa , [ganho][cocoasamurai-rac] [tração][raywenderlich-mvvm]
* [View-Interactor-Presenter-Entity-Routing (VIPER)][viper]
    * Uma arquitetura um pouco exótica que pode valer a pena olhar em um projetos de maior dimensão, onde mesmo o MVVM se sente confuso como uma das principais preocupações.

[mvcs]: http://programmers.stackexchange.com/questions/184396/mvcs-model-view-controller-store
[mvvm]: http://www.objc.io/issue-13/mvvm.html
[cocoasamurai-rac]: http://cocoasamurai.blogspot.de/2013/03/basic-mvvm-with-reactivecocoa.html
[raywenderlich-mvvm]: http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1
[viper]: http://www.objc.io/issue-13/viper.html

### “Eventos” Patterns

Estas são as formas idiomáticas para componentes notificarem outras coisas:

* __Delegation:__ _(um-para-um)_ Apple usa muito isso (alguns diriam, até demais). Use quando você quiser se comunicar com as coisas em volta e.g. da modal view.
* __Callback blocks:__ _(um-para-um)_ Permitir para mais um acoplamento fraco, while keeping related code sections close to each other. Also scales better than delegation when there are many senders.
* __Notification Center:__ _(um-para-muitos)_ Possivelmente a forma mais comum de objetos emitirem "eventos" para vários observadores. União muito solta — notificações podem até ser observadas globalmente sem referência ao objeto despachante.
* __Key-Value Observing (KVO):__ _(um-para-muitos)_ Não exige que o objeto seja observado explicitamente na "emitir eventos" desde que ele seja _Key-Value Coding (KVC)_ compatível para chaves observadas (propriedades). Geralmente não é recomendado devido a sua natureza implícita da biblioteca padrão da API.
* __Signals:__ _(um-para-muitos)_ A peça central do [ReactiveCocoa][reactivecocoa-github], Eles permitem que o encadeamento combine com o conteúdo do centro, oferecendo assim uma saída para [callback hell][elm-escape-from-callback-hell].

[elm-escape-from-callback-hell]: http://elm-lang.org/learn/Escape-from-Callback-Hell.elm

### Modelos

Mantém seus modelos imutáveis, e o usa para traduzir API'S semânticas remotas para seu app. Github  [Mantle](https://github.com/Mantle/Mantle) é uma boa escolha.

### Views

Quando colocar para fora seu ponto de vista usando o Auto Layout, não se esqueça de adicionar a seguinte sintax à sua classe:

    + (BOOL)requiresConstraintBasedLayout
    {
        return YES;
    }

Caso contrário você encontrará estranhos bugs quando o sistema não chamar  "-updateConstraints" como seria de se esperar.

### Controllers 

Use a injeção de depedência, i.e. passe todos os objetos necessários com parâmetros, em vez de manter todo o estado em torno do singletons. The latter is okay only if the state _really_ is global.

```objective-c
+ [[FooDetailsViewController alloc] initWithFoo:(Foo *)foo];
```

## Networking

### Caminho tradicional: Use callback de blocos personalizados 

```objective-c
// GigStore.h

typedef void (^FetchGigsBlock)(NSArray *gigs, NSError *error);

- (void)fetchGigsForArtist:(Artist *)artist completion:(FetchGigsBlock)completion


// GigsViewController.m

[[GigStore sharedStore] fetchGigsForArtist:artist completion:^(NSArray *gigs, NSError *error) {
    if (!error) {
        // Do something with gigs
    }
    else {
        // :(
    }
];
```

Isso funciona, mas pode levar rapidamente a um callback infernal se você precisar de várias cadeias de solicitações.

### Forma reativa: Use sinais RAC (Reactive Cocoa)

Se você se encontrar em um callback infernal, de uma olhada em [ReactiveCocoa (RAC)][reactivecocoa-github]. É uma biblioteca multiuso versátil e que pode mudar a maneira que as pessoas escrevem [total apps][groceryList-github], mas você também pode usá-lo com moderação onde ele se encaixa na tarefa.

Há boas instroduções para o conceito de RAC (e FRP em geral) em [Teehan+Lax][teehan-lax-rac] and [NSHipster][nshipster-rac].

[grocerylist-github]: https://github.com/jspahrsummers/GroceryList
[teehan-lax-rac]: http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/
[nshipster-rac]: http://nshipster.com/reactivecocoa/

```objective-c
// GigStore.h

- (RACSignal *)gigsForArtist:(Artist *)artist;


// GigsViewController.m

[[GigStore sharedStore] gigsForArtist:artist]
    subscribeNext:^(NSArray *gigs) {
        // Do something with gigs
    } error:^(NSError *error) {
        // :(
    }
];
```

Isso nos permite transformar ou filtrar apresentações antes de mostrar em seguida, combinando o sinal de atuação com outros sinais.

## Assets

[Catalogo de Asset ][asset-catalogs] são as melhores maneiras de gerencias todos seu projeto de visual assets. Eles podem manter igualmente universair em devices especificos (iPhone 4-polegadas, iPhone Retina, iPad, etc.) assets and will automatically serve the correct ones for a given name. Ensine seu designer como adicionar e da comite em coisas lá                                                         (Xcode has its own built-in Git client) can save a lot of time that would otherwise be spent copying stuff from emails or other channels to the codebase. It also allows them to instantly try out their changes and iterate if needed.

[asset-catalogs]: https://developer.apple.com/library/ios/recipes/xcode_help-image_catalog-1.0/Recipe.html

### Usando imagens bitmap

Catálogos de assets expõe apenas os nomes de conjuntos de imagens, abstraindo os nomes de arquivos reais dentro do conjunto. Este bem impede conflitos de nomes de assets, como arquivos "button_large@2x.png" são agora namespaced dentro de conjuntos de imagens. Entretanto, alguma intrução na nomeação dos assets torna a vida mais fácil:

```objective-c
IconCheckmarkHighlighted.png // Universal, non-Retina
IconCheckmarkHighlighted@2x.png // Universal, Retina
IconCheckmarkHighlighted~iphone.png // iPhone, non-Retina
IconCheckmarkHighlighted@2x~iphone.png // iPhone, Retina
IconCheckmarkHighlighted-568h@2x~iphone.png // iPhone, Retina, 4-inch
IconCheckmarkHighlighted~ipad.png // iPad, non-Retina
IconCheckmarkHighlighted@2x~ipad.png // iPad, Retina
```

Os modificadores `-568h`, `@2x`, `~iphone` e `~ipad` are not required per se, but having them in the file name when dragging the file to an image set will automatically place them in the right "slot", thereby preventing assignment mistakes that can be hard to hunt down.

### Usando imagens Vetores

Você pode incluir o original [Vetores gráficos (PDFs)][vector-assets] produzido por designers dentro dos catálogos de asset, e tem o Xcode que automaticamente gera um bitmap a partir dele. Este reduz a complexidade do seu projeto  (o número de arquivos gerenciáveis)

[vector-assets]: http://martiancraft.com/blog/2014/09/vector-images-xcode6/

## Estilo de Código

### Nomenclatura

Apple presta bastante atenção na consistencia da nomenclatura, algumas vezes um pouco verboso, ao longo de suas API's. Quando deselvove para Cocoa, torna isso mais fácil para novas pessoas que se juntam a você para um novo projeto [Apple's naming conventions][cocoa-coding-guidelines].

[cocoa-coding-guidelines]: https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html

Aqui está algumas dicas para voce começar a usar do modo certo:

Um metodo começando com um _verb_ indica que ele executa alguns efeitos colaterais, mas não retorna nada:
`- (void)loadView;`
`- (void)startAnimating;`

Qualquer metodo que começa com um _noun_, porém, retorna sem efeitos colaterais:
`- (UINavigationItem *)navigationItem;`
`+ (UILabel *)labelWithText:(NSString *)text;`

Vale a pena manter esses dois separados quando possível, i.e. não representa efeito colcatral wuando transforma data , e vice versa. Isso irá manter seus efeitos colaterais contido para seções menores do código, o que torna o mais compreensível e facilita na debugação.

### Estrutura (Structure)

[Pragma marks](http://nshipster.com/pragma/) é uma grande maneira para seu grupo de metodos, especialmente uma view controller. Aqui é comum uma estrutura trabalhar com quase qualquer view controller:

```objective-c

#import "SomeModel.h"
#import "SomeView.h"
#import "SomeController.h"
#import "SomeStore.h"
#import "SomeHelper.h"
#import <SomeExternalLibrary/SomeExternalLibraryHeader.h>

static NSString * const XYZFooStringConstant = @"FoobarConstant";
static CGFloat const XYZFooFloatConstant = 1234.5;

@interface XYZFooViewController () <XYZBarDelegate>

@property (nonatomic, copy, readonly) Foo *foo;

@end

@implementation XYZFooViewController

#pragma mark - Lifecycle

- (instancetype)initWithFoo:(Foo *)foo;
- (void)dealloc;

#pragma mark - View Lifecycle

- (void)viewDidLoad;
- (void)viewWillAppear:(BOOL)animated;

#pragma mark - Layout

- (void)makeViewConstraints;

#pragma mark - Public Interface

- (void)startFooing;
- (void)stopFooing;

#pragma mark - User Interaction

- (void)foobarButtonTapped;

#pragma mark - XYZFoobarDelegate

- (void)foobar:(Foobar *)foobar didSomethingWithFoo:(Foo *)foo;

#pragma mark - Internal Helpers

- (NSString *)displayNameForFoo:(Foo *)foo;

@end
```

O mais importante é quando mantém a consistência para cruzar classes em seu projeto .

### External Style Guides

Futurice não tem diretrizes de nível-empresa para estilo de codificação. No entanto ele pode ser útil para ler a guide style do Objective-C de outras lojas de desenvolvimento, mesmo que alguns pedaços podem ser bastante específicos da empresa:

* [GitHub](https://github.com/github/objective-c-style-guide)
* [Google](http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml)
* [The New York Times](https://github.com/NYTimes/objective-c-style-guide)
* [Ray Wenderlich](https://github.com/raywenderlich/objective-c-style-guide)
* [Sam Soffes](https://gist.github.com/soffes/812796)
* [Luke Redpath](http://lukeredpath.co.uk/blog/2011/06/28/my-objective-c-style-guide/)

## Diagnosticos (Diagnostics)

### Problemas de compilação 

É recomendado que você permita o maior número possível de avisos ao compilador, e tratar avisos de erro. essa recomendação é justificada em [Nessa representação de slides][warnings-slides]. Os slides The slides também contém informação sobre como conter certas advertências em arquivos específicos, ou em sessões especificas de código.

Em resumo, adicionar pelo menos estes valores para o _“Other Warning Flags”_ para construir definições :

- `-Wall` _(Enables lots of additional warnings)_
- `-Wextra` _(Enables more additional warnings)_

Também permite o  _“Treat warnings as errors”_ para construir definições.

[warnings-slides]: https://speakerdeck.com/hasseg/the-compiler-is-your-friend

### Analista estático Clang (Clang Static Analyzer)

O compilador clang (usando o Xcode) tem um _analista stático_ esse controla performance e fluxo de analise de data em seu código e verifica a existência de muitos erros que o compilador não pode. 

Você pode manualmente inicia analise no _Product → Analyze_ item no menu do Xcode.

O analista pode trabalhar em qualquer modo “raso"(shallow) ou modo “profundo”(deep). O último é muito mais lento, mas pode encontrar mais issues adequados para cruzar funções de controle e fluxo de analise de data.

Recomendações:

- Permite _todos_ de verificar no analizador (por permissão todos as opções no "Static Analizer" são definidas na sessão build.)
- Permitir a _“Analise durante a ‘Build’”_ definir a build para lançar a configuração da build para o analisador executar automaticamente durante a compilação. (Seriamente, fazer isso — você não vai lembrar de rodar isso manualmente .)
- Acionar o _“Modo de Análise para ‘Analyze’”_ construir a configuração _Shallow (faster)_
- Acionar o _“Modo de Análise para ‘Build’”_ construir a configuração _Deep_

### [Faux Pas](http://fauxpasapp.com/)

Criado por nós [Ali Rantakari][ali-rantakari-twitter], Faux Pas é uma fabulosa ferramente de detecção de erro estática. Ele analiza seu código fonte e encontra issues (questões) que você não tinha ideia que existia. Certifique-se de executar antes de enviar para qualquer app iOS (or Mac)!

_(Nota: Todos os funcionários da Futurice obtem uma licença livre para isso — basta perguntar Ali.)_

[ali-rantakari-twitter]: https://twitter.com/AliRantakari

### Debugando (Debugging)

Quando seu app crashes, Xcode não introduz no debugger por padrão. Para efetuar isso, adicione um exceção de breakpoint (clique no "+" no botão de Navigator Debug do Xcode) para parar a execução quando uma exceção é gerada. Em muitos casos, você vai ver a linha do código responsável pela exceção. Este captura qualquer exceção, mesmo os tratados. Xcode se mantém favorável na quebra de exceções na librarie de terceiros e.g., você pode ser capaz de suavizar isso escolhendo _Edit Breakpoint_ e definindo o _Exception_ drop-down para o _Objective-C_.

Para debugar a view, [Reveal][reveal] e [Spark Inspector][spark-inspector] são dois verificadores poderosos que você pode salvar horas do seu tempo, especialmente se você estiver usando Auto Layout e precisar localizar uma view que quebrou ou que está fora da tela. Permitindo, Xcode oferece [algo bem similar][xcode-view-debugging] de graça, mas é iOS 8+ único que se sente um pouco menos polido.

[reveal]: http://revealapp.com/
[spark-inspector]: http://sparkinspector.com
[xcode-view-debugging]: https://developer.apple.com/library/ios/recipes/xcode_help-debugger/using_view_debugger/using_view_debugger.html

### (Perfil) Profiling

Xcode vem com um conjunto de perfis chamado Instruments. Ele contém uma infinidade de ferramentas para perfis de uso de memória, CPU, comunicação com a rede, gráficos e muito mais. É uma besta complexa, mas um dos seus extras straight-forward casos de uso é rastrear vazamentos de memória com Allocations instrument. Simples escolha _Product_ > _Profile_ no Xcode, selecione a Allocation instrument, aperte o botão de Record para filtrar o resumo da Allocation em alguma string útil, como o prefixo do nome da sua própria classe. A contagem que persiste na coluna diz quantos instâncias de cada objeto você tem. Qualquer classe para qual a contagem de instância aumenta indiscriminadamente indica o vazamento de memória.

Também é bom saber se está Instruments tem uma ferramenta de Automation para gravação e reprodução de interação UI como arquivos Javascript. [UI Auto Monkey][ui-auto-monkey] é um script que usará a Automation para sofrer toques aleatorios no seu app, pancadas e rotação pode ser útil para teste de stress/pancada (swipes and rotations which can be useful for stress/soak testing.)

[ui-auto-monkey]: https://github.com/jonathanpenn/ui-auto-monkey

## Analytics

Incluir alguma análise de framework em seu app é altamente recomendado, um que lhe permita obter insights sobre como as pessoas realmente usam isso. Faz o recurso X adicionar valor? O button Y é difícil de encontrar? Para responder isso, você tem que enviar eventos, cronometrando e mensurando outras informações para um serviço que agrega ao visualiza-lo – para instância, [Google Tag Manager (gerenciador de marcação do google) ][google-tag-manager]. O último é mais versátil do que o Google Analytics em que se insere uma camada de dados entre o aplicativo e o Analytics, então essa lógica dos dados podem ser modificados através de um serviço web sem ter que atualizar o aplicativo.

[google-tag-manager]: http://www.google.com/tagmanager/

Uma boa prática é criar uma pequena classe auxiliar, e.g. "XYZAnalyticsHelper", que lida com a tradução a partir de modelos de aplicativos modelos e formatos de dados(XYZModel, NSTimeInterval, …) para principalmente camada de dado baseada por string:

```objective-c

- (void)pushAddItemEventWithItem:(XYZItem *)item editMode:(XYZEditMode)editMode
{
    NSString *editModeString = [self nameForEditMode:editMode];

    [self pushToDataLayer:@{
        @"event": "addItem",
        @"itemIdentifier": item.identifier,
        @"editMode": editModeString
    }];
}

```

Isto tem uma vantagem adicional permite que você troque todo framework do Analytics por trás se necessário, sem o resto do aplicativo perceber.

### Logs de Crash (Crash Logs)

Primeiramente você deve fazer o seu aplicativo enviar logs de crash para um servidor em algum lugar para que você possa acessá-lo. Você pode implantar isso manualmente (Usando [PLCrashReporter][plcrashreporter] em seu próprio backend) Mas é recomendado que você use um serviço existente, por exemplo um dos seguintes procedimentos:

* [Crashlytics](http://www.crashlytics.com)
* [HockeyApp](http://hockeyapp.net)
* [Crittercism](https://www.crittercism.com)
* [Splunk MINTexpress](https://mint.splunk.com)

[plcrashreporter]: https://www.plcrashreporter.org

Depois de ter configurado, garanta que você salve o arquivo Xcode (".xcarchive")_  em cada build que você lance. O arquivo contém o build do aplicativo binario e simbolos de debug ("dSYM") que você precisará simbolizar os reports de crash dessa versão particular do aplicativo.


## Building (Definição)

### Build Configurations (Configuração de build)

Mesmo simples aplicativos podem buildar de maneiras diferentes. A mais básica separação que o Xcode lhe dá é entre _debug_ e _release_ builds. Para a última, há muito mais otimização acontecendo em tempo de compilação, à custa da possibilidade da depuração (Debug). Apple sugestiona que você use o _debug_ build configuration para desenvolvedores, e crie seu pacote App Store usando o _release_ build configuration. Essa é codificada no esquema padrão (O menu suspenso ao lado dos botões Play e Stop no Xcode), qual o comando que o _debug_ pode ser utilizado para executar e arquivar a _release_.

Entretanto, isso é uma pouco simples demais para aplicação do mundo real. Você pode – , [_deveria!_][futurice-environments] – ter diferentes ambientes pra teste, staging e outras atividades relacionadas ao seu serviço. cada um pode ter sua base de URL, level de log, identificador de bundle (Então você pode instalar ele side-by-side), provisionando um perfil e etc.. Portanto uma distinção simples de debug/release não vai corta-la. Você pode adicionar mais configurações de build na tab "info" das definições de seu projeto no Xcode.

[futurice-environments]: https://blog.futurice.com/five-environments-you-cannot-develop-without

#### "xcconfig" arquivos para definições de build 

Tipicamente a definição de build é especificada no GUI do Xcode, mas você pode também usar _configuration settings files_ (“'.xcconfig' files”) para então. The benefits of using these are:

- Você pode adicionar comentários para explicar as coisas 
- Você pode `#include` outra definição de arquivo build, o que ajuda a evitar a repetição de si mesmo:
    - Se você tem alguma definição que se aplica à todas as definições de build, Adicione um `Common.xcconfig` e `#include` isso em todos os outros arquivos
    - Se você quer ter um “Debug” de definição habilitada build nas optimizações do compilador, você pode apenas adicionar `#include "MyApp_Debug.xcconfig"` e substituir um dos ajustes.
-  Resolução de conflitos e merging se torna mais fácil.

Enconte mais informação sobre esse tópico em [ Estas representações de slides][xcconfig-slides].

[xcconfig-slides]: https://speakerdeck.com/hasseg/xcode-configuration-files

### Targets 

Um target reside conceitualmente abaixo do nível do projeto, i.e. um projeto pode ter targets severos que podem substituir suas configuraçoes de projeto. Grosseiramente,  cada target corresponde a "um aplicativo" dentro do contexto do seu código fonte. Por exemplo, voce poderia ter aplicaçoes especificas de cada país (construido apartir do mesmo código fonte) para diferentes paises' App Stores. Cada uma delas terá development/staging/release builds, Por isso é melhor para lidar com aquelas da definição da build, nem targets. Não é incomum em todo um aplicativo ter uma única target.

### Esquemas (Schemes) 

 Esquemas (Schemes) diz ao Xcode o que deveria acontecer quando se inicia , (Teste) Test, (Perfil) Profile, (Análise ou ação de arquivo) Analyze or Archive action. Basicamente, eles mapeam cada uma dessas ações para a configuração da build. Voce também pode passar argumentos de lançamento, tais como o idioma do aplicativo que deve ser executado em (útil para testar sua localização!) ou definir algumas flags para diagnostico de depuração(Debbuger).

Uma sugestão de nomeamento convencional para esquemas é "MyApp (<Language>) [Environment]"  ("MyApp (<Linguagem) [Ambiente]") :

    MyApp (English) [Development]
    MyApp (German) [Development]
    MyApp [Testing]
    MyApp [Staging]
    MyApp [App Store]

Para maioria dos ambientes a lingua não é necessária, como o aplicativo provalvemente será instalado a partir de outros meios do Xcode, e.g. teste de lançamento, e o argumento de lançamento pode ser ignorado de qualquer maneira. Nesse caso, e o idioma do dispositivo deve ser definido manualmente para teste de localização.

## Deployment (Implantação)

Implantação (deployment) de software nos dispositivos iOS não é exatamente simples. That being said, aqui estão conceitos centrais que, umas vez entendido, irá ajuda-lo tremendamente com isto.

### Signing (Assinatura)

Sempre que você deseja executar o software em um dispositivo real (ao contrário do simulador), voce terá que assinar sua compilação com um __certificado__ emitido pela Apple.Cada certificado é ligado para uma par de chave privada/publica , a metade privada que reside em seu keychain do Mac. Há dois tipos de certificados:

* __Certificado de desenvolvimento:__ Cada desenvolvedor em uma equipe tem seu próprio, em que é gerado o pedido. Xcode pode fazer isso por voce, mas é melhor para não pressionar o botão magico "fix issue" e entender o que exatamente está ocorrendo. Este certificado é necessário para o desenvolvedor implantar builds para os devices.
* __Distribuição de certificado:__ Pode haver vários, mas é melhor mante-lo para uma organização, e compartilhar sua chave associada através de um canal interno. Este certificado é necessário para enviar para a App Store, ou sua organização interna "enterprise app store".

### Provisioning (Provisionamento)

Além de certificados, há também __provisioning profiles__, Que são basicamente o elo perdido entre o device e o certificado. Novamente, Existem dois tipos diferentes entre fins de desenvolvimento e distribuição:

* __ (perfil de provisionamento de desenvolvimento) Development provisioning profile:__ Ele contém uma lista de todos os dipositivos que estão autorizados a instalar e executar o software. Ela também é ligada a um ou mais certificados de desenvolvimento, um para cada desenvolvedor que tem permissão para utilizar o perfil. O profile dele pode ser vinculado a um aplicativo específico ou usar wildcard no ID do aplicativo (*). O último é [discouraged][jared-sinclair-signing-tips], porque o Xcode é notoriamente ruim em escolher os arquivos corretos para assinatura a menos que guie na direção certa. Também, certos recursos como Push Notification ou App Groups exijam explicitamente o ID do App.

* __Distribuição de perfil provisionado:__ Há diferentes maneiras de distribuição, para uso em cada caso diferente. Cada distribuição de perfil é ligado a uma distribuição certificada, e será inváido quando o certificado exprirar.
    * __Ad-Hoc:__ Assim como perfis de desenvolvimento, ele contém uma lista branca de dispositivos e aplicação que pode ser instalada para este tipo de perfil, que pode ser usado em testes betas em 100 dispositivos por ano. Para uma experiencia mais suave em até 100 usuários distintos, voce pode usar a recém adquirido serviço da Apple +[TestFlight][testflight]. Supertop oferece uma boa [summary of its advantages and issues][testflight-discussion].
    * __App Store:__ Este perfil não tem lista de dispositivos permitidos, como qualquer pessoa pode instala-la através do canal de distribuição oficial da Apple. Esse perfil é requerido para todos os lançamentos da Apple Store.
    * __Enterprise:__ Assim como App Store, não há lista branca de devices, e o aplicativo pode ser instalado por qualquer pessoa com acesso interno da conta da empresa na "App Store", que pode ser apenas um link de site . Esse perfil é disponível apenas em contas Enterprise.

[jared-sinclair-signing-tips]: http://blog.jaredsinclair.com/post/116436789850/
[testflight]: https://developer.apple.com/testflight/
[testflight-discussion]: http://blog.supertop.co/post/108759935377/app-developer-friends-try-testflight

Para sincronizar todos os certificados e perfis em sua maquina, vá para Accounts nas preferencias do Xcode, adicione seu ID da Apple se precisar, e de um clique-duplo no nome de sua equipe. Há um botão de atualização na parte inferior, mas algumas voce voce apenas precisara reinicializar o Xcode para mostra tudo.

#### Debugging Provisioning (Provisionamento de depuração)

Algumas vezes voce precisara debugar os issues de provisionamento. Por exemplo, o Xcode pode se recusar a instalar a compilação em um dispositivo conectado, por causa do último ser (development or ad-hoc) um perfil na lista . Nestes casos, voce pode usar a excelencia Craig Hockenberry[Provisioning][provisioning] plugin navegando para  `~/Library/MobileDevice/Provisioning Profiles`, selecionando um arquivo `.mobileprovision` e apertando space para iniciar a caracteristica do Quick Look do Finder. Ele ira mostrar-lhe uma riqueza de informações, tais como dispositivos, direitos, certificados, e ID do aplicativo.

[provisioning]: https://github.com/chockenberry/Provisioning

### Uploading

[iTunes Connect][itunes-connect] é um portal da Apple para gerenciar seus aplicativos na App Store. Para subir uma build, Xcode 6 requer um ID da Apple, isso faz parte da assinatura da conta do desenvolvedor. Isso pode tornar as coisas complicadas quando voce é parte de várias contas de desenvolvedores e quer fazer upload de aplicativos, por razões misteriosas qualquer ID da Apple só pode ser associada a uma única conta do iTunes Connect. Única solução alternativa é criar uma nova ID da Apple para cada conta da iTunes Connect voce precisa ser parte, e usar a Loader Application em vez do Xcode para subir a build.  Que efetivamente separa o processo de construção e assinatura do carregamento do resultante do arquivo do ".app".

Depois de subir o build, seja paciente pois pode levar até uma hora para aparecer na seção da Build do seu aplicativo. Quando aparecer, voce pode vincular para a versão do aplicativo e enviar o seu aplicativo para revisão.

[itunes-connect]: https://itunesconnect.apple.com

## In-App Compras (IAP)

Ao validar recibos de compra no in-app, lembre-se de fazer os seguintes comandos:

- __Authenticity:__ Que o recebimento vem da Apple
- __Integrity:__ Que o recibo não foi adulterado 
- __App match:__ Que o recebimento do bundle ID do aplicativo corresponde ao seu bundle identifier do aplicativo
- __Product match:__ Que o ID do produto no recebimento corresponde ao seu identificador do produto esperado
- __Freshness:__ Que voce não tenha visto o mesmo rebido do ID antes.

Sempre que possível,  projete seu sistema de IAP ( Inn-app) para armazenar o conteúdo para a venda do lado do servidor, e forneça para o cliente apenas em troca de um recibo válido que passa as verificações acima. Este tipo de projeto frusta mecanismos comuns de pirataria , e —  desde a validação é performada no servidor — permite voce de usar    Serviço de Recebimento  HTTP de validação da Apple como alternativa de interpretar o recibo  `PKCS #7` / `ASN.1` formato próprio.

Para mais informação neste tópico, veja a [Futurice blog: Validando uma compra pelo inn-app no seu aplicativo iOS][futu-blog-iap].

[futu-blog-iap]: http://futurice.com/blog/validating-in-app-purchases-in-your-ios-app

## License

[Futurice][futurice] • Creative Commons Attribution 4.0 International (CC BY 4.0)

[futurice]: http://www.futurice.com


## Mais Ideias

- 3x assets, tamanho da tela do iPhone 6 
- Adicionar lista de sugestões no alerta do compilador 
- Pergunte sobre IT automatizando maquinas de compilação Jenkins 
- Adicionar seção sobre Testes
- Adicionar "não comprovados "


[reactivecocoa-github]: https://github.com/ReactiveCocoa/ReactiveCocoa
